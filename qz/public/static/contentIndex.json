{"API/FSharp-Integration":{"title":"FSharp Integration","links":[],"tags":[],"content":"Imms is written primarily in C# and targets that language. But the library has a separate companion assembly, Imms.FSharp, that provides various extensions and modules for use with F#.\nThe following are the components of the F# Integration library.\nCommon Aliases ¬ß\nThe Imms library provides aliases for many collection-related types found in the .NET Framework, to better match F#‚Äòs concise style. Examples include:\n\nKvp&lt;&#039;k,&#039;v&gt; for KeyValuePair&lt;&#039;TKey, &#039;TValue&gt;.\nIEq&lt;&#039;a&gt; for IEqualityComparer&lt;&#039;T&gt;.\nICmp&lt;&#039;a&gt; for IComparer&lt;&#039;T&gt;\nIIter&lt;&#039;a&gt; for IEnumerator&lt;&#039;T&gt;\n\nModule bindings ¬ß\nThe F# companion library offers a module for each of the Imms collections, with module bindings for all the operations exposed by the standard interface. These modules also handle a few other things to make the collections more convenient to work with:\n\nConversion to and from F#‚Äòs function and Option types, as required.\nProvide a few extra functions to match the spirit of the F# collection library.\nImpose : equality and : comparison constraints, as required.\nProvide conversion to and from F# collection types.\n\nActive Patterns ¬ß\nThe F# companion library comes with a powerful set of active patterns for decomposing Imms sequential collections:\n\nLast(initial, last) allows decomposing collections from the end. Examples are Last1(initial, last), Last2(initial, last1, last2), etc.\nFirst(head, tail) allows decomposing collections from the beginning.\nMid(head, mid, last) allows decomposing a collection by one element from each side.\nNil matches an empty collection.\n\nCollection Expressions ¬ß\nThe F# library also provides computation expressions for building Imms collections. Here are some examples of how they are used:\nlet lst = immList {\n\tfor i in 0 .. 10 do yield i\n}\n \nlet map = immMap {\n\tfor i in 0 .. 10 do yield Kvp(i, i)\n}"},"API/Helper":{"title":"Helper","links":[],"tags":[],"content":"Each Imms collection has a static helper class with the same name. This helper class has methods for constructing collections, as well as extension methods for converting from one to another.\nvar list = ImmList.Of(1, 2, 3);\nvar set = ImmSet.Of(1, 2, 3);\nList ¬ß\nThe helper classes are the following:\n\nImmList\nImmSet\nImmMap\nImmSortedMap\nImmSortedSet\n"},"API/Indexing":{"title":"Indexing","links":[],"tags":[],"content":"Imms has several variations for indexing.\nNegative Indexing ¬ß\nImms collections support negative indexing, a feature borrowed from other languages such as Python. In this system, -1 denotes the last index, -2 the one before that, and so forth.\nYou can pass a negative index wherever you can pass any kind of index, including CopyTo, this[int], and others. You can‚Äôt pass negative numbers to methods like Take because they expect a count rather than an index.\nNegative indexing is particularly helpful when slicing a collection. For example, this[0, -4] returns the collection minus the last 3 items, while this[-4, -2] returns a slice consisting of the 4th, 3rd, and 2nd items from the end.\nSort order indexing ¬ß\nFor sorted collections, such as ImmSortedSet and ImmSortedMap, you can retrieve items by their index in the sort order using the method ByOrder(int index). ByOrder(0) corresponds to the minimum and ByOrder(-1) corresponds to the maximum.\nSlices ¬ß\nFor sequential collections, you can retrieve a slice of the collection using the indexer this[int start, int end]. For example, ImmList.Of(1, 2, 3)[0, 1] returns a list consisting of the first two elements.\nFor sets and maps, you can instead use the Slice(TKey start, TKey end) method, which returns a slice of the collection with keys between start and end. They keys themselves don‚Äôt have to be part of the collection, but they are included if they are."},"API/Key-Semantics":{"title":"Key Semantics","links":["API/Helper"],"tags":[],"content":"All keyed collections use custom key semantics by providing an IEqualityComparer&lt;T&gt; or IComparer&lt;T&gt; instance. You have to provide on of these unless your key type implements IEquatable&lt;T&gt; or IComparable&lt;T&gt;, in which case the default is used.\nYou can create instances that use custom key semantics using the Helper classes.\nImmSet&lt;string&gt; setWithComparer = ImmSet.Empty&lt;string&gt;(MyEqComparer);\nImmMap&lt;string&gt; mapWithComparer = ImmMap.Empty&lt;string&gt;(MyEqComparer);\nYou can also use extension methods defined directly on the key semantics objects.\nvar sortedMap = comparer.CreateSortedMap&lt;int, string&gt;();\nvar map = eqComparer.CreateMap&lt;int, int&gt;();\nInheritance ¬ß\nNew collection instances inherit the key semantics used by their source collection. It‚Äôs not possible to change the key semantics of a collection after it has been created.\nCompatibility ¬ß\nImms keyed collections support high-performance set-theoretic operations. These operations only work when all inputs are compatible. This means that their key semantics must be identical. Imms checks this using the following code, which defaults to reference equality:\nset.EqualityComparer.Equals(otherSet.EqualityComparer);\nIf you provide an incompatible collection, it will instead be treated as a n IEnumerable&lt;T&gt; and the high-performance implementation won‚Äôt be used.\nAll keyed and sorted collections support custom comparison logic via IComparer&lt;T&gt; or IEqualityComparer&lt;T&gt; instances, as well as default behavior for keys that implement IEquatable&lt;T&gt; or IComparable&lt;T&gt;."},"API/Operators":{"title":"Operators","links":[],"tags":[],"content":"Imms brings operators to the world of collections, resulting in more meaningful code.\nAdd ¬ß\nAll collections support + to add elements. For maps, the elements are key-value pairs.\n// Sets and maps support addition from the right:\nvar set = ImmSet.Of(1) + 2\nvar map = ImmMap.Of(Kvp.Of(1, 2)) + Kvp.Of(1, 2)\n// Lists support addition from both sides:\nvar list = 1 + ImmList.Of(2) + 3\nYou can also use + to join arrays and other collections.\nvar list = ImmList.Of(1, 2) + ImmList.Of(3, 4) + new[] {5, 6, 7};\nvar set = ImmSet.Of(1, 2) + ImmSet.Of(3, 4) + new[] {5, 6, 7};\nRemove ¬ß\nKeyed collections support - to remove specific keys. If the key isn‚Äôt found the collection will be returned unchanged.\nvar set = ImmSet.Of(1, 2, 3) - 1 - 2;\nvar map = ImmMap.Of(Kvp.Of(1, 2)) - 1\nYou can also pass a collection of keys, and Imms will remove all of them. This is the same as the Exclude operation.\nvar set = ImmSet.Of(1, 2, 3) - new[] {1, 2};\nvar map = ImmMap.Of(Kvp.Of(1, 1), Kvp.Of(2, 2), Kvp.Of(3, 3)) - new[] {1, 2};\nEquality ¬ß\nAll collections meaningfully override equality through both the Equals method and the == operator.\nvar x = ImmList.Of(1, 2) == ImmList.Of(1, 3) // False\nvar y = ImmSet.Of(1, 2) == ImmSet.Of(1, 2) // True\nIntersection ¬ß\nvar intersected = ImmSet.Of(1, 2) &amp; ImmSet.Of(1)\nUnion ¬ß\nUnion is supported using both | and + for sets.\nvar union1 = ImmSet.Of(1, 2) | ImmSet.Of(3) + ImmSet.Of(4)\nSymmetric difference ¬ß\nvar set1 = ImmSet.Of(1, 2, 3);\nvar set2 = ImmSet.Of(3, 4, 5);\n \nvar intersection = set1 &amp; set2;\nvar symmetricDifference = set1 ^ set2;"},"API/Optional":{"title":"Optional","links":[],"tags":[],"content":"The Optional&lt;T&gt; type is a really useful feature that indicates an optional value of type T.\nWhy do you need it? ¬ß\nIn particular, why not just use null and nullable types?\nUniformity/Abstraction ¬ß\nThe .NET framework does not have a single nullable type that can be used to indicate an optional value. It has two distinct kinds of types, nullable value types and (nullable) reference types.\nThis means it‚Äôs not possible to write a method like this:\n///Returns the first element in the list, or None if it&#039;s empty.\nOptional&lt;T&gt; TryFirst { ... }\nBecause replacing Optional&lt;T&gt; with T? is invalid for reference types, and saying T : class would be absurdly restrictive.\nThis is why the .NET framework is littered with ugly and inconvenient things like:\nbool TryGet(TKey key, out TValue value);\nLess ambiguity ¬ß\nThe fact a reference type is nullable means it‚Äôs implicitly optional. That is, all reference types behave kind of like Optional&lt;T&gt; in that they may not exist. However, in most cases, people do not expect a reference type to be null, or else it‚Äôs just treated as a kind of invalid value that indicates a bug.\nThis is one of the reasons nulls are so bad. But optional values make perfect sense in many cases. You just need to be clear about what‚Äôs optional and what isn‚Äôt. And optional types let you do that.\nEasier Debugging ¬ß\nNulls are problematic because they are hard to debug. A NullReferenceException tells you next to nothing about what caused the error, partly because anything could be null, and partly because nulls do not contain any runtime type information.\nNone values, in contrast, are still values and do contain information. So when a NoValueException is thrown, you also get the underlying type and possibly some other information.\nYou can also see additional info in the debugger, where for a null value you‚Äôd just see‚Ä¶ null.\nYou can call instance members ¬ß\nSince optionals aren‚Äôt evil nulls, you can call instance members on them, even when they indicate a missing value. This means you can still use ToString, Equals, and GetHashCode, for example.\nHow does it work? ¬ß\nThe Imms optional type is a non-nullable value type. It is different from F#‚Äòs Option type.\nAn Optional&lt;T&gt; has two states: Some(T), in which it wraps a value of type T, and None, in which it wraps no value.\nYou can check what state it‚Äôs in using the following code:\nOptional&lt;T&gt; x;\nif(x.IsSome) {\n    //x is Some\n}\nif (x.IsNone) {\n    //x is None\n}\nAnd you can expose the underlying value (if any) using:\nOptional&lt;int&gt; s = Optional.Some(5);\nint v = s.Value;\nNote that calling Value on a None instance throws an exception (a NoValueException, a subtype of InvalidOperationException, is thrown in this case). The exception provides more information than NullReferenceException, such as the underlying type.\nNote that the None values of optionals with different types are functionally distinct in some cases, but are still equal under Equals and GetHashCode. They may also be compared using the == operator.\nThere is an assortment of methods for interacting with optional values, such as .Map, .Cast, .Or, etc.\nHow is it used in Imms? ¬ß\nOptionals are used quite often in Imms, almost every time a value may or may not exist. They‚Äôre also often used in optional parameters, though not always (usually for the sake of brevity).\nHere are some examples:\n\nFindIndex, which may not find the index in question.\nTryGet, which may not find the key in question.\nPick, which takes a function that returns an Optional.\n\nHow do I make one? ¬ß\nYou can create an instance of an optional value in several ways.\nThe Optional helper class ¬ß\nThe Optional static class contains a number of static methods for constructing optional values. You can use the use static feature of C# 6 to integrate it better with the language.\n\nOptional.Some(x) wraps x in a Some value.\nOptional.None returns a special token that can be implicitly converted to the None value of any optional type.\nOptional.NoneOf&lt;T&gt; returns a typed None value.\n\nExtension methods ¬ß\nThe extension method AsOptional (several overloads) lets you convert concrete values into optional values. It maps null values to None values.\nImplicit conversions ¬ß\nThere is an implicit conversion from T to Optional&lt;T&gt;, so the following code works:\nOptional&lt;int&gt; x = 5;\nThere is also an explicit conversion from Optional&lt;T&gt; to T, so the following code compiles but may throw an exception:\nOptional&lt;int&gt; x;\nint y = (int)x;\nWhat can I do with it? ¬ß\nSee the documentation of the Optional set of classes for more information, but here is a short list of special operations this type supports.\nMapping ¬ß\nMapping is similar to C# 6‚Äôs conditional access operator, ?. (one of the several things you‚Äôll be missing out on, unfortunately). It applies a function on the underlying value, if any, or propagates a None:\nOptional&lt;int&gt; n = 5;\nOptional&lt;string&gt; str = n.Map(x =&gt; x.ToString());\nIt also has an overload that lets the function return Optional too:\nOptional&lt;int&gt; n = 5;\nOptional&lt;string&gt; str = n.Map(x =&gt; x % 2 == 0 ? Some(x.ToString()) : None);\nCoalescing ¬ß\nThis works similar to the ?? operator, another goody:\nOptional&lt;int&gt; a = 5;\nint b = a.Or(6);\nIt also has an overload in which the default value is also optional:\nvar a = Some(5);\nvar b = Some(6);\nOptional&lt;int&gt; c = a.Or(b);\nEquating ¬ß\nYou can equate optionals with other optionals, both using the == operator and using the .Equals method. Equality is structural. Two optionals of different declared types may be equal if their underlying values are equal. All None values are equal, whatever the underlying type.\nOptional parameters ¬ß\nYou can use optionals for optional parameters, but this usage is a bit tricky. This is because those need to have default value which is a compile-time constant, and optionals are structs that can‚Äôt take on the null value.\nHowever, this problem can be solved, albeit in a rather verbose way:\nvoid ExampleMethod(Optional&lt;int&gt; a = default(Optional&lt;int&gt;)) {\n    //...\n}\nThis technique is mainly useful when you want to accept an optional parameter of type T, which (as mentioned previously), cannot be achieved otherwise."},"API/PowerLINQ":{"title":"PowerLINQ","links":[],"tags":[],"content":"Imms overrides LINQ operations, such as Select and Where with optimized implementations that return a collection of the same type as the input. This also means that they don‚Äôt execute lazily.\n‚Äú\nLook at the following code as an example:\nImmList&lt;string&gt; names = ImmList.Of(&quot;greg&quot;, &quot;maya&quot;, &quot;steve&quot;, &quot;franklin&quot;);\nImmList&lt;string&gt; startWithG = \n\tfrom name in names\n\twhere name.StartsWith(&quot;g&quot;)\n\tselect name;\n \nImmList&lt;string&gt; peopleInBothLists =\n\tfrom name in names\n\tjoin name2 in startWithG on name equals name2\n\torderby name\n\tselect name;\nImms.Abstract ¬ß\nImms implements LINQ operations and other functionality through the Imms.Abstract assembly. This assembly contains highly abstract base classes and interfaces that Imms collections inherit from and implement.\nThis works like the much-vaunted Scala collections API, except that C# doesn‚Äôt have Scala‚Äôs type system, so this turned out to be quite difficult. I eventually settled on a combination of:\n\nSome boilerplate that needs to be implemented for each collection\nA lot of generic code in base classes\nSome code genertion templates\n\nThe system can be reused by more specialized collections."},"Collections/ImmList":{"title":"ImmList","links":[],"tags":[],"content":"\n\n                  \n                  Examples \n                  \n                \nSee some code!\n\nImms offers a single sequential collection, ImmList. It‚Äôs the flagship collection of the library, with support for a large variety of useful operations, optimal time complexities, and blazing fast real-world performance.\nEnds ¬ß\nSupports O(1) access to the ends via AddLast and AddFirst.\nBulk ¬ß\nSupports optimized bulk operations for adding multiple elements.\nIndexing ¬ß\nFast O(logn) lookup, update, insert, and remove.\nComplexity ¬ß\nThe computational complexity of Imms sequential collections and comparable non-Imms collections can be seen below.\n\nPerformance ¬ß\nThe collections have been put through thorough benchmarking and compared against similar collections from other libraries. These results are from one benchmarking session, with a specific number of iterations and other parameters. However, the parameters between different tests and test groups are comparable.\nFor example, the AddLast benchmark might‚Äôve been executed for 100,000 iterations, while the AddLastRange benchmark might‚Äôve been executed with input datasets of 10,000 elements 10 times.\n"},"Collections/ImmMap":{"title":"ImmMap","links":["Collections/ImmSet","API/Key-Semantics"],"tags":[],"content":"ImmMap is an immutable hash map and the library‚Äôs primary map collection. It‚Äôs implemented as an AVL tree and uses most of the same code as ImmSet. Keys must normally implement IEquatable&lt;K&gt;, but see more about this here.\nIt has a sorted variant that uses IComparable&lt;K&gt; and IComparer&lt;K&gt; instead.\n\n\n                  \n                  Examples \n                  \n                \nSee some code!\n\nOperations ¬ß\nImmMap supports a wide variety of highly optimized, key-based operations derived from its set counterpart.\nMerge (Union) ¬ß\nThis operation merges two maps. It combines their key-value pairs using the key semantics of the current map, returning a map including the key-value pairs of both. A selector can be supplied, which determines the value in case of collision. The function takes the key, the value in the current map, and in the value in the input map. This selector is called the join selector.\nWithout a selector, the value in the input map is used.\nJoin (Intersection) ¬ß\nThis operation joins two maps. It matches every key in the current map with every key in the input map. You can supply a selector that determines the value in the output. Otherwise, the value in the input map is used. This selector is called the join selector.\nWithout a selector, the value in the input map is used.\nThis operation is similar to the LINQ join operator.\nSubtract (Except) ¬ß\nThis one subtracts the input map from the current map. A selector is applied on all the key-value pairs shared by the two maps. This selector returns an Optional value. If it is Some(v), then the key-value pair is retained with the value v. Otherwise, if it is None, the key-value pair is removed. This selector is called the subtraction selector.\nWithout a selector, the key-value pair is simply removed.\nDifference (Difference) ¬ß\nThis method returns a map consisting of all the key-value pairs in exactly one map. No selector can be supplied in this case.\nComplexity ¬ß\nMaps have the same complexity bounds as sets:\n\nPerformance ¬ß\n\n"},"Collections/ImmSet":{"title":"ImmSet","links":["API/Key-Semantics"],"tags":[],"content":"ImmSet is an immutable hash set, implemented as an AVL tree, and it‚Äôs the library‚Äôs primary set collection. Elements must normally implement IEquatable&lt;T&gt;.\nIt also has a sorted variant that uses IComparer&lt;T&gt; and IComparable&lt;T&gt;.\n\n\n                  \n                  Examples \n                  \n                \nSee some code!\n\nOperators ¬ß\nImmSet supports the basic membership, addition, and removal operations. It also supports highly optimized set-theoretic operations. See Key Semantics when collections with custom comparison logic are involved.\n\nUnion\nIntersection\nExcept\nSymmetric difference, often called simply Difference.\nExceptInverse, which is the opposite of Except.\n\nThese operations take an IEnumerable&lt;T&gt;, which taken to be a collection of elements. The operations are performed using the current instance‚Äôs membership semantics, even if the input is also a set with different membership semantics. Type testing is performed internally to determine the actual type of the input.\nThe input can contain duplicates. They are ignored.\nThese methods are highly optimized for compatible sets of the same type. See more about set compatiblity below. The methods are also optimized for other kinds of inputs. As always, iterators will give the worst performance.\nRelations ¬ß\nThe sets support set-theoretic relation operators, including:\n\nIsSubsetOf and related methods. These test for a specific relation.\nRelatesTo, which returns an enum value indicating the relation between two sets.\n\nThe input is an IEnumerable&lt;T&gt; here as well.\nComplexity ¬ß\nHere is a rundown of the complexity of each operation, which just showcases what we‚Äôve discussed previously:\n\nImmSet and ImmSortedSet have the same time complexity per operation, with the exception that ImmSet is a hash set that uses buckets, and therefore the performance is averaged over the inputs, and assumes a decent GetHashCode implementation.\nPerformance ¬ß\n\n\n"},"Why/Immutable-collections":{"title":"Immutable collections","links":[],"tags":[],"content":"An immutable and persistent collection is one that can‚Äôt be changed, but still supports operations such as Add and Remove.\nInstead of actually changing the collection itself, these operations transform the collection, returning a new one with the desired modifications.\nThis rather intuitive behavior is very similar to how strings work in .NET. It‚Äôs also similar to how numbers work, for that matter.\nThis is how operations on immutable and persistent objects look like:\n/** String: **/\nvar str = &quot;Hello World&quot;;\nvar newStr = str + &quot;!&quot;;\n//still: str == &quot;Hello World&quot;\n \n/** Integer: **/\nvar n = 5;\nvar m = n + 1;\n//still: n == 5\n \n/** Imms Collection: **/\nvar immList = ImmList.Of(1, 2, 3);\nvar newImmList = immList.AddLast(4);\n//still: immList == [1, 2, 3]\nIn contrast, a mutable object behaves like this:\nvar mutableList = new List&lt;int&gt;() {1, 2, 3};\nmutableList.Add(4);\n//mutableList != [1, 2, 3] :(\nIn the latter example, the mutableList object has been mutated, and its original value information is gone.\nNow, why is the behavior in the first example better than in the second one?\nThat‚Äôs a trick question, of course. It really isn‚Äôt. It‚Äôs just different. Both kinds of collections are useful in different circumstances.\nStructural sharing ¬ß\nStrings achieve their persistence by directly copying the whole thing every time you transform it. This works well for small amounts of data, but is impractical and prohibitive for collections that can potentialy contain thousands of elements. It‚Äôs expensive in both time and memory.\nThe immutable and persistent collections provided by Imms support an optimization known as structural sharing. Basically, when you transform a collection (such as by adding an element to the end), the resulting collection shares almost all of its structure with the previous one, with only small differences.\nSo if you have a million collections, each with a million elements and each differing in only a single element, you can only require as much memory as ten collections, an incredible optimization.\nGeneral Advantages ¬ß\nThese general advantages apply no matter what kind of code you‚Äôre writing.\nSafer Code ¬ß\nMutation makes code more error-prone and harder to analyze. Using immutable objects unless there is reason not to helps reduce the complexity of the program and can get rid of bugs before they appear.\nTight control over state ¬ß\nSince immutable collections cannot be changed, you can expose them (possibly in behind interfaces) without fear for the internal state of an object, while still giving the user the full functionality of the collection.\nThis is best illustrated with the familiar example of strings. If you expose a string, the user can build upon it and transform it, but can‚Äôt change it behind your back. If you expose a List&lt;char&gt;, however, the user can change it without your knowledge.\nIn contrast, if you expose it as IEnumerable&lt;char&gt;, the user can‚Äôt change it behind your back, but can‚Äôt leverage the unique functionality of a string either.\nThread safety ¬ß\nSince immutable collections cannot be changed, the thread safety of a single instance is not an issue. Any number of reading threads can be active at the same time without interfering with anything else.\nAlthough multiple writing threads can run into problems of working on out-dated information, this can be solved with locks that never interfere with reading.\nFurthermore, ‚Äúchanging‚Äù an immutable collection basically amounts to changing a reference, which is an atomic operation.\nSharing ¬ß\nIf you want to use the same collection in different locations but don‚Äôt want mutations in one location to affect another, you have to copy it, which can be prohobitively expensive.\nAn immutable collection instance never changes, so it never needs to be copied. You can have references to it in multiple locations in your code without any danger.\nSnapshots and history tracking ¬ß\nAs an example, a persistent collection lets you use snapshots to perform history tracking. You can efficiently store snapshots of a collection as it changes.\nImplement other immutable objects ¬ß\nWhile you can easily use immutable objects to implement mutable ones (and, in fact, your objects will be less error-prone for it), you cannot use mutable objects to implement immutable ones.\nThus, if you want to create an object that provides one or more of the above benefits, and you need to use a collection in that object, you‚Äôll have to use one that‚Äôs immutable.\nMore Reading ¬ß\nFor more discussion about mutability versus immutability, see the following related links:\n\nWhy immutable collections?\nObjects Should Be Immutable\nJava theory and practice: To mutate or not to mutate?\n"},"Why/Not-immutable-collections":{"title":"Not immutable collections","links":[],"tags":[],"content":"Sometimes, however, you want to use a mutable collection.\nWhen mutation is desirable ¬ß\nPerhaps the most obvious reason to avoid immutable collections (at least directly) is that mutation is desirable. This often involves some kind of change notification mechanism.\nHowever, you can still use immutable and persistent collections to implement mutable collections, and the result can still benefit from some of the things we talked about above.\nPerformance ¬ß\nFor most operations, immutable and persistent collections will under-perform against mutable ones, largely because they have a more complex structure and some extra objects must be allocated with every operation.\nFurthermore, persistent collections always inflict more load on the garbage collector, since many old versions of collections aren‚Äôt needed and can be abandoned.\nThese problems can be partially aleviated by using a system of mutable builders, and the library is built with this in mind (however, it hasn‚Äôt been implemented yet).\nAlso, note that Imms collections are still extremely fast, and are unlikely to bottleneck an application."},"index":{"title":"index","links":["Collections/ImmList","Collections/ImmSet","Collections/ImmMap","optional","helper","indexing","API/Operators"],"tags":[],"content":"\n\n                  \n                  Last updated 2016 \n                  \n                \n\nHigh-performance immutable collections for .NET. Try them!\n\n\n                  \n                  Features \n                  \n                \n\n\n                  \n                  ü§π Five immutable collections! \n                  \n                \n\n\n\n                  \n                  üíé Uniform and full-featured API! \n                  \n                \n\n\n\n                  \n                  üöÄ Aggressively optimized! \n                  \n                \n\n\n\n                  \n                  üíØ Fully tested and documented! \n                  \n                \n\n\nImmList ¬ß\nSimilar to List&lt;T&gt;. The flagship collection of the library. Supports a large variety of operations with lightning-fast performance and optimal time complexity.\nImmSet ¬ß\nA hash set similar to HashSet&lt;T&gt;. Supports fast set-theoretic operations and relations. Has a sorted variant.\nImmMap ¬ß\nA hash map similar to Dictionary&lt;K, V&gt;. Supports unique map operations, such as join, difference, and exclude. Has a sorted variant.\nAPI ¬ß\nImms collections come with a carefully designed, uniform API.\n\n\n                  \n                  Optional \n                  \n                \nAn optional type that supports many of the library‚Äôs features.\n\n\n\n                  \n                  Helper classes \n                  \n                \nCreate instances of collections using helper classes\n\n\n\n                  \n                  Indexing \n                  \n                \nSupports negative indexing and slices using indexers.\n\n\n\n                  \n                  PowerLINQ \n                  \n                \nPowerLINQ overrides standard LINQ operators with high-performance, strongly-typed implementations.\n\n\n\n                  \n                  Operators \n                  \n                \nMeaningfully overloads Operators\n\n\n\n                  \n                  F# Integration \n                  \n                \nGet [[FSharp Integration|F# Integration]] for custom active patterns, operators, and modules.\n"}}